* 树
节点的高度 = 节点到叶子节点的最长路径(边数)
节点的深度 = 根节点到这个节点所经历的边的个数
节点的层数 = 节点的深度 + 1
树的高度 = 根节点的高度

记住这几个概念的小窍门:
生活中的"高度", 是从下往上度量, 如高楼, 且计数从0开始
生活中的"深度", 是从上往下看, 如水井, 是从水平面开始度量的, 计数从0开始
"层数"与"深度"类似, 计数从1开始.
[[file:~/notes/clea/images/tree_notion.png][树的概念]]

* 二叉树
每个节点最多只有2个节点.
完全二叉树: 叶子节点都在最底下两层, 最后一层的叶子节点都靠左排列, 并且除了最后一层, 其他层
的节点个数都要达到最大, 这种二叉树叫做完全二叉树.

满二叉树: 除了叶节点以外, 每个节点都有左右两个子节点.

堆其实就是一种完全二叉树, 最常用的存储方式就是数组.

** 二叉树的遍历
前序遍历: 根-左-右, 递推公式: preOrder(r)=print(r)->preOrder(r->left)->preOrder(r->right)
中序遍历: 左-根-右, 递推公式: inOrder(r)=inOrder(r->left)->print(r)->inOrder(r->right)
后序遍历: 左-右-根, 递推公式: postOrder(r)=postOrder(r->left)->postOrder(r->right)->print(r)

** 题目
1. 给定一组数据, 共有n个数据, 可以构建出多少种不同的二叉树?
   结果是卡特兰数, C[n, 2n]/(n+1).

* 二叉查找树
二叉查找树最大的特点就是支持动态数据集合的快速插入、删除、查找操作.

二叉查找树的要求: 在树中的任意一个节点, 其左子树中的每个节点值, 都要小于这个节点的值, 右子树节点
的值都大于这个节点的值.

二叉查找树中序遍历的结果是有序数据序列, 时间复杂度是O(n), 因此也叫做二叉排序树.


** 支持重复数据的二叉查找树
实际的软件开发中, 二叉查找树中存储的是一个包含很多字段的对象, 利用对象的某个字段作为键值来构建
二叉查找树, 将对象中的其他字段叫做卫星数据.

如果存储的两个对象键值相同, 有两种解决方法.
1. 二叉查找树中每个节点不仅会存储一个数据, 通过链表和支持动态扩容的数组等数据结构, 把值相同的数据
   都存储在同一个节点上.
2. 每个节点任然值存储一个数据, 在查找插入位置的过程中, 如果碰到一个节点的值, 与要插入数据的值相同
   就将这个要插入的数据放到这个节点的右子树, 即把这个新插入的数据当作大于这个节点的值来处理.
   此时查找操作时, 遇到值相同的节点, 并不停止查找, 而是继续在右子树中查找, 直到遇到叶子节点, 才
   停止.
   对于删除操作, 也需要先找到要删除的每个节点, 然后在按前面讲的删除操作方法, 依次删除.

** 时间复杂度分析
