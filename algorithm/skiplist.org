* 跳表
跳表是一种各方面性能都比较优秀的动态数据结构, 可以支持快速的插入、删除、查找操作, 常用于代替
红黑树.

Redis中的有序集合就是用跳表来实现的.

** 跳表理解
对于一个单链表, 即便链表中的内容是有序存储的, 要查找也只能是从头到尾遍历链表. 时间复杂度为O(n).

为了提高查找效率, 可以对单链表建立一级"索引", 如图: [[file:~/notes/clea/images/skiplist.png][一级跳表]], 图中的down表示down指针, 指向下一
级的节点. 此时如果要查找某个节点, 如13, 可以先在索引层遍历, 当遍历到索引层中值为13的节点时,
发现下一个节点为17, 查找的16只能位于这两个节点之间, 然后通过索引层节点的down指针, 下降到原始链表
这一层, 继续遍历即可.

从该例中可以看出, 加上一层索引后, 查找一个节点需要遍历的节点个数少了, 即查找效率提高了.

这种链表加多级索引的结构, 就是跳表.

** 跳表的时间复杂度
根据跳表的定义, 如果每两个节点抽出一个节点作为上一级索引的节点, 则第一级索引的节点个数大约是n/2,
第二级索引的节点个数大约就是n/4, ..., 即k级索引的节点个数是第k-1级索引的节点个数的1/2, 则第k级
索引节点的个数就是n/(2^k).

假设有h级索引, 最高级的索引有两个节点, 则n/(2^h) = 2, h=(logn) - 1. 如果包含原始链表这一层, 整个
跳表的高度就是logn, 在跳表中查询某个数据的时候, 如果每一层都要遍历m个节点, 则在跳表中查询一个数据
的时间复杂度就是O(m*lgn).

按照前面的索引结构, 每一级索引最多只需要遍历3个节点. 证明如下:
假设查找的数据为x, 在第k级索引中, 遍历到y节点后, 发现x大于y, 小于后面的z节点, 所以通过y的down指针
从第k级索引下降到第k-1级索引, 在第k-1级索引中, y和z之间只有3个节点(包含y, z), 在k-1级索引中最多
只需要遍历3个节点.

** 跳表的空间复杂度
假设原始链表大小为n, 第一级索引大约有n/2, 第二级索引大约有n/4, ..., 最终为:
n/2 + n/4 + ... + 8 + 4 + 2 = n-2, 因此为O(n).

如果每3个节点抽取一个建立索引, 第一级大约为n/3, 第二级大约为n/9, ..., 最终为:
n/3 + n/9 + ... + 9 + 3 + 1 = n/2, 任然为O(n), 但比上面的减少了约一半的索引结构空间.

实际上在软件开发中, 不必太在意索引占用的额外空间, 因为原始链表中存储的数据可能是很大的对象,
而索引节点只需要存储关键值和几个指针, 当对象比索引节点大很多时, 索引占用的额外空间就可以忽略了.

** 跳表索引动态更新
当不停的往跳表中插入数据时, 如果不更新索引, 就可能出现某2个索引节点之间数据非常多的情况, 极端
情况下, 跳表会退化成单链表.

跳表是通过随机函数来维护"平衡性"的.
当往跳表中插入数据时, 可以选择同时将这个数据插入到部分索引层中, 索引层的选择通过一个随机函数来
决定. 如果随机函数生成了值k, 就将该节点添加到第一级到第k级索引中.

** redis中有序集合使用跳表的原因
按照区间查找数据这个操作, 跳表可以做到O(logn)的时间复杂度定位区间的起点, 然后在原始链表中顺序
往后遍历就可以了.

跳表不能完全代替红黑树. 很多编程语言中的Map类型都是通过红黑树来实现的.
跳表需要自己实现.

[[https://cloud.tencent.com/developer/article/1353762][redis源码跳表阅读参考]]
