* 递归
** 满足递归的条件
1. 一个问题的解可以分解为几个子问题
2. 该问题与分解后的子问题除了数据规模不同, 求解思路完全一样
3. 存在递归终止条件

** 递归的基本法则
1. 基准情形: 不用递归就能求解
2. 不断推进, 对于需要用递归求解的情形, 递归调用必须总能朝着产生基准情形的方向推进
3. 设计法则: 假设所有的递归调用都能运行
4. 合成效益法则: 在求解一个问题的同一实例时, 切勿在不同的递归调用中做重复性的工作.
   典型的例子就是用递归方法计算斐波那契数列, 斐波那契数列的递推公式是: F(n) = F(n-1) + F(n-2)

** 如何编写递归代码
关键点是: 写出递推公式, 找到终止条件.
即: 找到将大问题分解为小问题的规律, 并且基于此写出递推公式, 然后再推敲终止条件,
最后将递推公式和终止条件翻译为代码.

** 递归的正确思维方式
如果一个问题A可以分解为若干子问题B、C、D. 可以假设子问题B、C、D已经解决, 在此基础上思考如何解决
问题A. 而且只需要思考问题A与子问题B、C、D两层之间的关系即可, 不需要一层一层往下思考子问题与子子
问题, 子子问题与子子子问题之间的关系, 屏蔽掉递归细节.

即: 只要遇到递归, 就将其抽象成一个递推公式, 不用想一层层的调用关系, 不要试图用人脑去分解递归
的每个步骤.

** 递归代码注意事项
1. 要警惕堆栈溢出
2. 警惕重复计算
   为了避免重复计算, 可以通过一个数据结构(如散列表)来保存已经求解过的值. 当递归调用时, 先看
   是否已经求解过了.
3. 递归代码中有很多函数调用, 这些函数调用的数量较大时, 就会集聚成一个可观的时间成本.

** 将递归代码改为非递归代码
例子1: 循环递归计算当前排数的问题
#+BEGIN_SRC c
// 递归代码:
int currank(int n) {
    if(n == 1) return 1;
    return f(n-1) + 1;
}

// 非递归代码
int currank(int n) {
    int ret = 1;
    for(int i=2; i<=n; ++i) {
        ret = ret + 1;
    }
    return ret;
}
#+END_SRC

例子2: 斐波那契数列
#+BEGIN_SRC c
// 递归代码
int feibo(int n) {
    if(n == 1) return 1;
    if(n == 2) return 2;
    return feibo(n-1) + feibo(n-2);
}

// 非递归代码
int feibo(int n) {
    if(n == 1) return 1;
    if(n == 2) return 2;
    
    int ret, pre=2, prepre=1;
    for(int i=3; i<=n; ++i) {
        ret = pre + prepre;
        pre = ret;
        prepre = pre;
    }
    return ret;
}
#+END_SRC

** 尾递归 - 递归的一种优化
尾递归如果在得到编译器的帮助下, 完全可以避免栈溢出的问题.
原因是: 每个函数在调用下一个函数前, 都能做到先把自己占用的栈空间先给释放了, 因此尾递归可以做到
只有一个函数在使用栈, 因此可以无限的调用.

递归函数改写为尾递归的方法: 把所有用到的内部变量改写成函数的参数.
例如: 上例中的递归计算当前排数的问题, 改成尾递归的形式如下:
#+BEGIN_SRC c
int f(int n, int r) {
    if(n <= 1) return r+1;
    return f(n-1, 1+r);
}

// 调用
int r = f(5, 1);
#+END_SRC

以输出链表的节点为例:
#+BEGIN_SRC c
void printlist(list l) {
    if(l != NULL) {
        printelement(l->el);
        printlist(l->next);
    }
}

// 改为非递归的方式, 尾递归可以通过将递归调用变成goto语句并在其加上对每个函数的
// 赋值语句而手工消除.
void printlist(list l) {
top:
    if(l != NULL) {
        printelement(l->el);
        l = l->next;
        goto top;
    }
}
#+END_SRC

** 尾调用
概念: 指某个函数的最后一步是调用另一个函数. 如:
#+BEGIN_SRC c
// 尾调用
int f(x) {
    return g(x);
}

// 非尾调用
int f(x) {
    int y = g(x);
    return y;
}

// 非尾调用
int f(x) {
    return g(x) + 1;
}
#+END_SRC
尾调用不一定出现在函数尾部, 只要是最后一步操作即可.
#+BEGIN_SRC c
int f(x) {
    if(x > 0) return m(x);
    return n(x);
}
#+END_SRC

** 柯里化 - currying
函数式编程中的一个概念,  意思是将多参数的函数转换成单参数的形式.

** 题目
1. 如何自动检测A-B-C-A这种递归"环"的存在.
2. 汉罗塔问题
