* 散列表
散列表用的是数组支持按照下标随机访问数据的特性, 散列表其实就是数组的一种扩展, 由数组演化而来.
可以说没有数组, 就没有散列表.

散列表用的就是数组支持按照下标随机访问的时候, 时间复杂度是O(1)的特性. 通过散列函数把元素的键值
映射为下标, 然后将数据存储在数组中对应下标的位置. 到按键查找元素时, 用同样的散列函数, 将键值转化
为数组下标, 从对应的数组下标的位置取数据.

** 散列函数
设计散列函数的基本要求:
1. 散列函数计算得到的散列值是一个非负整数
2. 如果key1 = key2, 则hash(key1) == hash(key2)
3. 如果key1 != key2, 则hash(key1) != hash(key2)
4. 散列函数的设计不能太复杂
5. 散列函数生成的值要尽可能随机并且均匀分布.

在设计散列函数时, 无法完全避免散列冲突, 并且数组的存储空间有限, 也会加大散列冲突的概率.

** 散列冲突解决方法
1. 开发寻址法
   如果出现了散列冲突, 就重新探测一个空闲位置, 将其插入.
   线性探测: 如果某个数据经过散列函数后, 存储位置已经被占用了, 就从当前位置开始, 依次往后查找,
   直到找到空闲位置

   线性探测法存在的问题: 当散列表中插入的数据越来越多时, 散列冲突发生的可能性就会越来越大.

   对于开放寻址冲突解决方法, 除了线性探测方法之外, 还可以使用二次探测和双重散列.
   二次探测: 每次探测的下标序列就是hash(key)+0, hash(key)+1^2, hash(key)+2^2, ...
   
   双重散列: 不仅要使用一个散列函数, 使用一组散列函数.

   不管采用哪种探测方法, 当散列表中空闲位置不多时, 散列冲突的概率就会大大提高, 此时一般会使用
   装载因子来表示空位的多少.

   装载因子计算公式:
   散列表装载因子 = 填入表中的元素个数/散列表的长度

   优点:
   可以有效利用CPU缓存加快查询速度, 并且序列化起来比较简单.
   当前数据量比较小, 装载因子小的时候, 适合采用开放寻址法.
2. 链表法
   在散列表中, 每个桶都会对应一条链表, 所有散列值相同的元素都放到相同槽位对应的链表中.
   基于链表的散列冲突处理方法比较适合存储大对象, 大数据量的散列表, 支持更多的优化策略, 如可以使用
   红黑树代替链表

** 散列表碰撞攻击的基本原理
攻击者通过精心构造的数据, 使得所有的数据经过散列函数之后, 都散列到同一个桶中, 如果使用的是基于
链表的冲突解决方法, 此时, 散列表会退化为链表, 查询的时间复杂度就从O(1)急剧退化为O(n).
这样就有可能因为查询操作消耗大量CPU或者线程资源, 导致系统无法响应其他请求, 从而达到拒绝服务攻击(
DoS)的目的.

** 工业级散列表的特性
1. 支持快速查询、插入、删除操作
2. 内存占用合理
3. 性能稳定, 极端情况下, 散列表的性能也不会退化到无法接受的情况.

** 题目
1. 假设有10w条URL访问日志, 如何按照访问次数给URL排序?
2. 有两个字符串数组, 每个数组大约有10w条字符串, 如何快速找出两个数组中相同的字符串?
3. LRU缓存系统的设计
   [[file:~/notes/clea/images/lru.png][lru数据示意图]]
   使用双向链表存储数据, 链表中每个节点处理存储数据、前驱指针、后继指针之外, 还有一个hnext.
   因为散列表是通过链表法解决散列冲突的, 所以每个节点会在两条链中, 一个链就是存储数据本身的双向
   链表, 另一个就是散列表中的拉链.
   前驱和后继指针是为了将节点串在双向链表中, hnext指针是为了将节点串在散列表的拉链中.
4. 假设有10w个猎头, 如何在内存中存储10w个猎头ID和积分信息, 让其支持这样的操作:
   根据猎头的ID快速查找、删除、更新该猎头的积分信息
   查找积分在某个区间的猎头ID列表
   查找按照积分从小到大排名在第x位到第y位之间的猎头ID列表

* hash算法
将任意长度的二进制映射为固定长度的二进制值串.

hash算法需要满足如下几点要求:
1. 从哈希值不能反向推导出原始数据 - hash算法也叫做单向hash算法
2. 对输入数据非常敏感, 哪怕原始数据只修改了一个bit, 最后得到的hash值也大不相同
3. 散列冲突的概率要小, 对于不同的原始数据, hash值相同的概率非常小
4. hash算法的执行效率要尽量高效, 针对较长的文本, 也能快速地计算hash值.

** 应用
1. 安全加密
   最常用的加密算法是MD5, SHA, DES, AES
2. 唯一标识
3. 数据校验
   例如BT下载软件. 其中一种思路为:
   假设一个2G的文件被分成了100块, 通过哈希算法对100个文件块分别取hash值, 并且保存在种子文件中.
   当文件块下载完成后, 可以通过相同的hash算法对下载好的文件块逐一求hash值, 然后跟种子文件中保存
   的hash值对比. 如果不同, 需要再重新从其他宿主机上下载这个文件块.
4. 散列函数
5. 负载均衡
6. 数据分片
7. 分布式存储
   一致性hash算法, 简称DHT, 是MIT提出的一种算法.
   简单理解如下: [[https://www.sohu.com/a/158141377_479559][参考链接]]
   a. 把全量的缓存空间当做一个环形存储结构, 环形空间总共分成2^32个缓存区, 在Redis中则是把缓存key分配
   到16384个slot中.
   b. 每个缓存key都可以通过hash算法转化为一个32位的二进制数, 即对应着环形空间的某个缓存区,
   将所有的缓存key映射到环形空间的不同位置.
   c. 每个缓存节点也遵循同样的hash算法, 比如用IP做hash, 映射到环形空间中.
   d. 每个key的顺时针方向最近节点就是key所归属的存储节点
   e. 当增加节点时, 整个环形空间的映射任然会保持一致性hash的顺时针规则, 只有部分key的归属会受到
   影响
   f. 删除节点也是类似的
   g. 为了优化节点太少而产生的不均衡情况, 一致性hash算法引入了"虚拟节点"的概念
      即基于原来的物理节点映射出N个子节点, 最后把所有的子节点映射到环形空间上.

