* 排序算法
学习排序算法, 最重要的是要学会如何评价、分析一个排序算法. 分析一个算法可以从如下几个方面入手:
1. 排序算法的执行效率
   最好情况、最坏情况、平均情况时间复杂度
   时间复杂度的系数、常数、低阶: 在实际的软件开发中, 排序可能是10个、100个、1000个这样规模很小
   的数据, 因此需要将系数、常数、低阶考虑进来.
   比较次数和交换次数
2. 排序算法的内存消耗
   原地排序: 特指空间复杂度为O(1)的排序算法.
3. 排序算法的稳定性
   稳定性: 如果待排序的序列中存在值相等的元素, 经过排序后, 相等元素之间的原有先后顺序不变

[[https://visualgo.net/][算法的动态图]]

https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ

* 冒泡排序
冒泡排序只会操作相邻的两个数据, 每次冒泡操作都会对相邻的两个元素进行比较, 看是否满足大小关系.
一次冒泡会让至少一个元素移动到它应该在的位置, 重复n次就完成了n个数据的排序工作.

[[file:~/notes/clea/code/bubblesort.c][冒泡排序代码]]

** 分析
1. 冒泡排序是原地排序算法
   只需要常量级的临时空间.
2. 是稳定的排序算法
   在冒泡排序算法中, 只有交换才可以改变两个元素的前后顺序, 为了保证冒泡排序的稳定性, 当相邻两个
   元素大小相等的时候, 不做交换即可.
3. 时间复杂度为
   最好情况下, 数据已排序, 需要进行一次冒泡, 就可以结束, 所以最好为O(N)
   最坏情况下, 数据是倒序排列, 需要进行n次冒泡, 所以为O(N^2)
4. 可以用链表实现

** 另一种思路来分析排序算法的平均时间复杂
有序度: 数组中具有有序关系的元素对的个数, 有序元素对用数学表达式表示就是:
a[i]<=a[j], i<j

如: 2,4,3,1,5,6则组数据的有序度为11, 分别是:(2,4), (2,3), (2,5), (2,6), (4,5), (4,6), (3,5),
(3,6), (1,5), (1,6), (5, 6)

对于一个倒序排列的数组, 其有序度为0.
对于一个完全有序的数组, 有序度就是n*(n-1)/2.
将完全有序的数组的有序度叫做满有序度.

逆序度的正义正好跟有序度相反. 逆序度 = 满有序度 - 有序度
排序的过程就是一种增加有序度, 减少逆序度的过程, 最后达到满有序度, 就说明排序完成了.

以数据"4 5 6 3 2 1"为例, 有序度为3, 满有序度是15.
冒泡排序包含两个操作原子, 比较和交换, 每交换一次, 有序度就加1.

* 插入排序

[[file:~/notes/clea/code/insertsort.c][插入排序代码]]

** 分析
1. 插入排序是原地排序.
2. 插入排序是稳定排序
3. 插入排序的时间复杂为O(N^2)
4. 可以用链表实现

* 选择排序
思路有点儿类似插入排序, 分为已排序和未排序区间. 选择排序每次会从未排序区间中找到最小的元素, 将其
放到已排序的末尾.

[[file:~/notes/clea/code/selectsort.c][选择排序代码]]

** 分析
1. 原地排序
2. 时间复杂度为O(N^2)
3. 非稳定排序
4. 可以用链表实现

* 归并排序
思想: 要排序一个数组, 先把数组从中间分成前后两部分, 然后对前后两个部分分别排序, 再将排好序的
两部分合并在一起, 这样整个数组就有序了.

归并排序使用的就是分治思想.
分治算法一般是使用递归实现的. 分治是一种解决问题的思路, 递归是一种编程技巧.

归并排序的递推公式是:
merge_sort(p...r) = merge(merge_sort(p...q), merge_sort(q+1...r))
终止条件是: p >= r不再继续分解



* 快速排序
