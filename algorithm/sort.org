* 排序算法
学习排序算法, 最重要的是要学会如何评价、分析一个排序算法. 分析一个算法可以从如下几个方面入手:
1. 排序算法的执行效率
   最好情况、最坏情况、平均情况时间复杂度
   时间复杂度的系数、常数、低阶: 在实际的软件开发中, 排序可能是10个、100个、1000个这样规模很小
   的数据, 因此需要将系数、常数、低阶考虑进来.
   比较次数和交换次数
2. 排序算法的内存消耗
   原地排序: 特指空间复杂度为O(1)的排序算法.
3. 排序算法的稳定性
   稳定性: 如果待排序的序列中存在值相等的元素, 经过排序后, 相等元素之间的原有先后顺序不变

[[https://visualgo.net/][算法的动态图]]

https://mp.weixin.qq.com/s/HQg3BzzQfJXcWyltsgOfCQ

* 冒泡排序
冒泡排序只会操作相邻的两个数据, 每次冒泡操作都会对相邻的两个元素进行比较, 看是否满足大小关系.
一次冒泡会让至少一个元素移动到它应该在的位置, 重复n次就完成了n个数据的排序工作.

[[file:~/notes/clea/code/bubblesort.c][冒泡排序代码]]

** 分析
1. 冒泡排序是原地排序算法
   只需要常量级的临时空间.
2. 是稳定的排序算法
   在冒泡排序算法中, 只有交换才可以改变两个元素的前后顺序, 为了保证冒泡排序的稳定性, 当相邻两个
   元素大小相等的时候, 不做交换即可.
3. 时间复杂度为
   最好情况下, 数据已排序, 需要进行一次冒泡, 就可以结束, 所以最好为O(N)
   最坏情况下, 数据是倒序排列, 需要进行n次冒泡, 所以为O(N^2)
4. 可以用链表实现

** 另一种思路来分析排序算法的平均时间复杂
有序度: 数组中具有有序关系的元素对的个数, 有序元素对用数学表达式表示就是:
a[i]<=a[j], i<j

如: 2,4,3,1,5,6则组数据的有序度为11, 分别是:(2,4), (2,3), (2,5), (2,6), (4,5), (4,6), (3,5),
(3,6), (1,5), (1,6), (5, 6)

对于一个倒序排列的数组, 其有序度为0.
对于一个完全有序的数组, 有序度就是n*(n-1)/2.
将完全有序的数组的有序度叫做满有序度.

逆序度的正义正好跟有序度相反. 逆序度 = 满有序度 - 有序度
排序的过程就是一种增加有序度, 减少逆序度的过程, 最后达到满有序度, 就说明排序完成了.

以数据"4 5 6 3 2 1"为例, 有序度为3, 满有序度是15.
冒泡排序包含两个操作原子, 比较和交换, 每交换一次, 有序度就加1.

* 插入排序

[[file:~/notes/clea/code/insertsort.c][插入排序代码]]

** 分析
1. 插入排序是原地排序.
2. 插入排序是稳定排序
3. 插入排序的时间复杂为O(N^2)
4. 可以用链表实现

* 选择排序
思路有点儿类似插入排序, 分为已排序和未排序区间. 选择排序每次会从未排序区间中找到最小的元素, 将其
放到已排序的末尾.

[[file:~/notes/clea/code/selectsort.c][选择排序代码]]

** 分析
1. 原地排序
2. 时间复杂度为O(N^2)
3. 非稳定排序
4. 可以用链表实现

* 归并排序
思想: 要排序一个数组, 先把数组从中间分成前后两部分, 然后对前后两个部分分别排序, 再将排好序的
两部分合并在一起, 这样整个数组就有序了.

归并排序使用的就是分治思想.
分治算法一般是使用递归实现的. 分治是一种解决问题的思路, 递归是一种编程技巧.

归并排序的递推公式是:
merge_sort(p...r) = merge(merge_sort(p...q), merge_sort(q+1...r))
终止条件是: p >= r不再继续分解

[[file:~/notes/clea/images/mergesort.jpg][归并排序图解]]

[[file:~/notes/clea/code/mergesort.c][归并排序代码]]

归并排序算法的核心部分其实就是merge(合并)的部分, 前面会一直拆分数据, 直到最后剩下两个元素的时候
开始合并数据, 因此需要注意递归的深度问题.
TODO: merge函数还可以通过哨兵的方式优化代码? HOW

** 分析
1. 稳定性取决于合并函数, 合并前后顺序不变即可, 因此是一个稳定排序
2. 时间复杂度 O(nlgn)
3. 空间复杂度 O(n)
4. 可以用链表实现

* 快速排序
快排利用的也是分治思想. 有点儿想归并, 但思路完全不一样.

其思想是: 如果要排序数组中下标从p到r之间的一组数据, 选择p到r之间的任意一个诗句作为pivot(分区点).
遍历p到r之间的数据, 将小于pivot的放到左边, 将大于pivot的放到右边, 将pivot放到中间. 这一步之后,
数组p到r之间的数据就被分成了3部分, 前面p到q-1之间都是小于pivot的, 中间是pivot, 后面的q+1到r之间
是大于pivot的.
根据分治、递归思想, 可以用递归排序下标从p到q-1之间的数据和q+1到r之间的数据, 直到区间缩小为1.

递推公式: quick_sort(p...r) = quick_sort(p...q-1) + quick_sort(q+1...r)
终止条件: p>=r

[[file:~/notes/clea/code/quicksort.c][快速排序代码]]

** 分析
1. 非稳定排序
2. 时间复杂度O(nlgn), 最坏情形可能会退化到O(n^2)
3. 原地排序
4. 可以用链表实现

** 查找第K大的元素
使用快速排序中的分区函数即可实现.
[[file:~/notes/clea/code/findkthlarge.c][查找第k大的元素]]
* 桶排序
将要排序的的数据分到几个有序的桶里, 每个桶里的数据再单独进行排序. 桶内排完序之后, 再把每个桶里的
数据按照顺序依次取出, 组成的序列就是有序的.

时间复杂度的计算:
假设要排序的数据有n个, 将其均匀的划分到m个桶内, 每个桶里有k=n/m个元素. 每个桶内部使用快速排序,
时间复杂度为O(k*logk), m个桶排序的时间复杂度是O(m*k*logk), 因为k=n/m, 所以整个桶排序的时间复杂
度为O(n*log(n/m)). 当桶的个数m接近数据个数n时, log(n/m)就是一个非常小的常量, 此时就接近O(n)

桶排序比较适合用在外部排序中.

外部排序: 数据存储在外部磁盘中, 数据量比较大, 内存有限, 无法将数据全部加载到内存中.

* 计数排序
计数排序其实是桶排序的一种特殊情况. 当要排序的n个数据所处的范围不大的时候, 比如最大值为k. 就可以
将数据划分成k个桶, 每个桶内的数据值都是相同的, 省掉了桶内排序的时间.

[[file:~/notes/clea/code/countsort.c][计数排序代码]]

计数排序只能用在数据范围不大的场景中, 如果数据范围k比要排序的数据n大很多, 就不适合用计数排序了.
计数排序只能给非符整数排序, 如果要排序的数据是其他类型的, 要将其在不改变相对大小的情况下, 转化
为非负整数.

* 基数排序
基数排序对要排序的数据是有要求的, 需要可以分割出独立的"位"来比较, 而且位之间有递进关系, 如果a
数据的高位比b数据大, 剩下的低位就不用比较了. 并且每一位的数据范围不能太大, 要可以用线性排序算法
来排序, 否则, 基数排序的时间复杂度就无法做到O(n).

[[file:~/notes/clea/images/radixsort.png][基数排序图解]]

** 题目
1. 假设现在需要对D, a, F, B, c, A, z这个字符串进行排序, 要求将其中的所有小写字母都排在大写字母
   的前面, 但大小写内部不要求有序.
   [[file:~/notes/clea/code/charactersort.c][字符排序代码]]
2. 假设字符串中存储的不仅有大小写字母, 还有数字, 要将小写字母放到前面, 大写字母在最后, 数字在中间
   不用排序算法, 如何解决呢?
   [[file:~/notes/clea/code/hollandproblemsort.c][荷兰国旗问题代码]]

* 如何选择合适的排序算法
** 如何优化快速排序
快速排序出现O(n^2)的时间复杂度的主要原因是: 选择的分区点不够合理.

最理想的分区点是: 被分区点分开的两个分区中, 数据量差不多.

比较常用的分区算法:
1. 三数取中
   从区间的首、尾、中间分别取出一个数, 然后对比大小, 取3个数的中间数作为分区点.
2. 随机法
   每次从要排序的区间中, 随机选择一个元素作为分区点

