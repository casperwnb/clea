* 链表
** 定义
链表不需要一块连续的内存空间, 通过"指针"将一组零散的内存块串联起来使用.

链表结构有很多, 常见的有: 单链表、双向链表、循环链表.

** 写链表代码的技巧
1. 理解指针或引用的含义
   指针: 将某个变量赋值给指针, 实际上就是将这个变量的地址赋值给指针, 即指针中存储了这个变量的地址
2. 警惕指针丢失和内存泄漏
   在插入或删除节点时, 一定要注意操作指针的顺序.
   删除节点时, 要记得释放内存.
3. 利用哨兵简化实现难度
   [[file:~/notes/clea/code/guard_use.c][哨兵优化查询的代码]]
   在链表中, 可以使用带有头结点的链表来简化链表的操作.
4. 留意边界条件的处理
   经常用来检测链表代码的边界条件有:
   链表为空、链表只包含一个结点时、链表只包含两个节点时、代码逻辑在处理头结点和尾节点时、
   代码逻辑在处理头结点和尾节点时是否能正常工作.
5. 举例画图、辅助思考
6. 多写多练
   熟练掌握:
   单链表反转 - 迭代法(done), 递归法(还不太理解) #TODO
   链表中环的检测 - 快慢指针
   两个有序的链表合并
   删除链表倒数第n个节点 - 快慢指针
   求链表的中间节点 - 快慢指针
   leetcode中的链表题目

** 链表 - 使用数组实现(也叫游标)

** 链表的应用场景
1. LRU缓存淘汰算法 - 实现思路
   维护一个有序单链表, 越靠近链表尾部的节点越是之前访问的. 当有一个新数据被访问时, 从链表头
   开始顺序遍历链表. 如果数据之前已经被缓存在链表中了, 遍历得到这个节点数据对应的节点, 将其从
   原来的位置删除, 然后再插入到链表的头部

   如果数据没有在链表中, 分为两种情况:
   如果此时缓存未满, 则将此节点直接插入到链表的头部
   如果已满, 则链表尾节点删除, 将新节点插入到链表头部

2. Java的LinkedHashMap使用双向链表

** 练习题目
1. 实现基于链表的LRU
2. 如何判断一个字符串是否是回文字符串, 字符串是通过单链表来存储的
   思路: 使用快慢指针
   快指针每步走两格, 当快指针到达链表末端的时候, 慢指针到达中心, 并且慢指针在走的时候还把走过的
   节点反向了, 在中心点再开辟一个新的指针用于往回走, 而慢指针继续向前, 当慢指针扫完整个链表, 就
   可以判断是否是回文串了. 该算法的时间复杂度是O(n), 空间复杂度是O(1).
   [[file:~/notes/clea/code/linklist_palindromic.c][使用链表实现的回文数判断]]
3. 约瑟夫环
4. 逆序打印链表
   [[file:~/notes/clea/code/linklist_reverseprint.c][递归逆序打印链表]]
